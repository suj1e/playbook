# 20. Valid Parentheses / 有效的括号

[中文链接](https://leetcode.cn/problems/valid-parentheses/) | [English](https://leetcode.com/problems/valid-parentheses/)

**难度**：Easy
**标签**：栈 | 字符串
**相似题目**：[lc-22](./lc-22-generate-parentheses.md) | [lc-32](./) | [lc-301](./)
**面试频次**：⭐⭐⭐⭐⭐

---

## 题目描述

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1**：
```
输入：s = "()"
输出：true
```

**示例 2**：
```
输入：s = "()[]{}"
输出：true
```

**示例 3**：
```
输入：s = "(]"
输出：false
```

**示例 4**：
```
输入：s = "([)]"
输出：false
```

**示例 5**：
```
输入：s = "{[]}"
输出：true
```

**约束条件**：
- 1 <= s.length <= 10⁴
- s 仅由括号 `'()[]{}'` 组成

---

## 解题思路

### 方法一：栈（推荐）

**思路**：
遇到左括号入栈，遇到右括号时检查栈顶是否为匹配的左括号。

**复杂度**：
- 时间：O(n)
- 空间：O(n)

**步骤**：
1. 遍历字符串
2. 遇到左括号，入栈
3. 遇到右括号：
   - 栈为空，返回 false
   - 栈顶不匹配，返回 false
   - 栈顶匹配，出栈
4. 遍历结束，检查栈是否为空

---

## 代码实现

### Java

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> stack = new ArrayDeque<>();

        for (char c : s.toCharArray()) {
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);  // 左括号入栈
            } else {
                // 右括号
                if (stack.isEmpty()) {
                    return false;  // 栈为空，无法匹配
                }

                char top = stack.pop();
                // 检查是否匹配
                if (c == ')' && top != '(') return false;
                if (c == ']' && top != '[') return false;
                if (c == '}' && top != '{') return false;
            }
        }

        return stack.isEmpty();  // 栈必须为空
    }
}
```

### Python

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {')': '(', ']': '[', '}': '{'}

        for c in s:
            if c in mapping.values():  # 左括号
                stack.append(c)
            else:  # 右括号
                if not stack or stack[-1] != mapping[c]:
                    return False
                stack.pop()

        return len(stack) == 0
```

---

## 关键点

| 关键点 | 说明 |
|-------|------|
| 左括号入栈 | 遇到左括号时入栈，等待匹配 |
| 右括号匹配 | 遇到右括号时检查栈顶是否为对应的左括号 |
| 栈空判断 | 右括号时栈为空，说明没有左括号匹配 |
| 最终检查 | 遍历结束后栈必须为空（所有左括号都有匹配） |
| 匹配规则 | `()` `[]` `{}` 必须成对匹配 |

---

## 图解

```
输入: "{[]}"

步骤:
1. '{' -> 左括号, 入栈
   stack: ['{']

2. '[' -> 左括号, 入栈
   stack: ['{', '[']

3. ']' -> 右括号, 检查栈顶
   栈顶 = '[', 匹配! 出栈
   stack: ['{']

4. '}' -> 右括号, 检查栈顶
   栈顶 = '{', 匹配! 出栈
   stack: []

5. 遍历结束, 栈为空, 返回 true

---

输入: "(]"

步骤:
1. '(' -> 左括号, 入栈
   stack: ['(']

2. ']' -> 右括号, 检查栈顶
   栈顶 = '(', 与 ']' 不匹配!
   返回 false
```

---

## 变种/延伸

### 变种1：生成括号
- **题目**：[lc-22 括号生成](./lc-22-generate-parentheses.md)
- **变化**：生成 n 对括号的所有有效组合
- **解法**：回溯/DFS

### 变种2：最长有效括号
- **题目**：[lc-32 最长有效括号](./)
- **变化**：找最长的有效括号子串
- **解法**：栈/动态规划

### 变种3：删除无效括号
- **题目**：[lc-301 删除无效括号](./)
- **变化**：删除最少的括号使字符串有效
- **解法**：BFS/回溯

### 变种4：括号分数
- **题目**：[lc-856 括号的分数](./)
- **变化**：计算括号嵌套的分数
- **解法**：栈/递归

### 进阶思考

1. **为什么用栈？**
   - 括号匹配是"后进先出"的典型场景
   - 最内层的括号最先匹配

2. **可以用其他数据结构吗？**
   - 可以用计数器（仅适用于一种括号）
   - 多种括号必须用栈

3. **如何生成所有有效的括号组合？**
   - 回溯算法
   - 保证左括号数量 >= 右括号数量

4. **如何计算有效括号的分数？**
   - `()` = 1，`AB` = A + B，`(A)` = 2 × A
   - 递归或栈都可以

5. **如果字符串很长，如何优化空间？**
   - 空间复杂度已经是 O(n)
   - 如果只有一种括号，可以用计数器优化到 O(1)
