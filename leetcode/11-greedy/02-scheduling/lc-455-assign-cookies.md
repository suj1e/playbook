# 455. Assign Cookies / 分发饼干

[中文链接](https://leetcode.cn/problems/assign-cookies/) | [English](https://leetcode.com/problems/assign-cookies/)

**难度**：Easy
**标签**：贪心 | 数组 | 双指针 | 排序
**相似题目**：[lc-135](./) | [lc-406](./) | [lc-376](./)
**面试频次**：⭐⭐⭐

---

## 题目描述

假设你是一位很棒的家长，想要给你的孩子们分发饼干。

每个孩子最多只能给一块饼干。

对于每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大值。

**示例 1**：
```
输入：g = [1,2,3], s = [1,1]
输出：1
解释：
你有三个孩子和两块小饼干，3 个胃口值分别是 1, 2, 3。
虽然你有两块小饼干，由于尺寸都是 1，你只能满足胃口值为 1 的孩子，所以输出 1。
```

**示例 2**：
```
输入：g = [1,2], s = [1,2,3]
输出：2
解释：
你有两个孩子和三块饼干，两个孩子的胃口值分别是 1, 2。
你拥有的饼干数量和尺寸都足以让所有孩子满足，所以输出 2。
```

**示例 3**：
```
输入：g = [10,9,8,7], s = [5,6,7,8]
输出：2
解释：
你可以满足胃口值为 7,8 的孩子，有 3 块饼干，但只满足了 2 个。
```

**约束条件**：
- 1 <= g.length <= 3 * 10⁴
- 0 <= g[i], s[j] <= 5 * 10⁴
- 胃心值和尺寸可以相同

---

## 解题思路

### 方法一：贪心（推荐）

**思路**：
大饼干满足大胃口，小饼干满足小胃口。

**复杂度**：
- 时间：O(n log n)
- 空间：O(1)

**步骤**：
1. 将 g 和 s 排序
2. 双指针遍历
3. 如果饼干能满足孩子，都向后移动
4. 如果不能满足，只移动孩子指针（找更小的胃口）

---

## 代码实现

### Java

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);

        int child = 0, cookie = 0;

        while (child < g.length && cookie < s.length) {
            if (s[cookie] >= g[child]) {
                child++;  // 满足这个孩子
            }
            cookie++;  // 无论如何都用掉这个饼干
        }

        return child;
    }
}
```

### Python

```python
from typing import List

class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()

        child = cookie = 0

        while child < len(g) and cookie < len(s):
            if s[cookie] >= g[child]:
                child += 1
            cookie += 1

        return child
```

---

## 关键点

| 关键点 | 说明 |
|-------|------|
| 双排序 | 先对胃口和饼干排序 |
| 双指针 | child 和 cookie 分别移动 |
| 满足条件 | 饼干尺寸 >= 孩子胃口 |
| 贪心策略 | 小饼干给小胃口，大饼干给大胃口 |
| 饼干消耗 | 无论是否满足都消耗掉 |

---

## 图解

```
g = [10,9,8,7], s = [5,6,7,8]

排序后:
g = [7,8,9,10], s = [5,6,7,8]

双指针过程:
child=0, cookie=0:
  g[0]=7, s[0]=5, 5<7, 不满足
  cookie=1

child=0, cookie=1:
  g[0]=7, s[1]=6, 6<7, 不满足
  cookie=2

child=0, cookie=2:
  g[0]=7, s[2]=7, 7>=7, 满足!
  child=1, cookie=3

child=1, cookie=3:
  g[1]=8, s[3]=8, 8>=8, 满足!
  child=2, cookie=4

child=2, cookie=4:
  超界, 退出

结果: child = 2

满足的孩子:
- 第1个(胃口7): 饼干7
- 第2个(胃口8): 饼干8

不满足:
- 第3个(胃口9): 没有足够大的饼干
```

---

## 变种/延伸

### 变种1：分糖果 II
- **题目**：[lc-135 分糖果 II](./)
- **变化**：每个孩子都有相邻的限制条件
- **解法**：单次遍历或两次遍历

### 变种2：买卖股票的最佳时机
- **题目**：[lc-122 买卖股票的最佳时机 II](../../09-dp/05-stock/lc-122-best-time-to-buy-and-sell-stock-ii.md)
- **变化**：股票交易，累加所有上升段
- **解法**：贪心，累加正收益

### 进阶思考

1. **为什么先排序？**
   - 贪心策略要求有序
   - 小饼干对小胃口，大饼干对大胃口
   - 需要按大小匹配

2. **为什么小饼干优先？**
   - 如果大饼干先给小胃口，浪费了
   - 小饼干给小胃口最合适
   - 大饼干还能留给大胃口

3. **孩子或饼干有重复元素怎么办？**
   - 排序后可能有重复
   - 贪心策略仍然有效
   - 重复元素不影响算法

4. **如何记录分配方案？**
   - 记录每个孩子获得的饼干
   - 修改返回类型为 List<List<Integer>>

5. **如何处理复杂胃口？**
   - 贪心策略依然有效
   - 排序后仍然是从前往后匹配

6. **如果饼干数量不足？**
   - 所有孩子都无法满足
   - 返回 0
   - 指针会遍历完所有饼干

7. **如何证明贪心的正确性？**
   - 交换法：如果有更优解，可以交换证明
   - 如果最优解中某个孩子被大饼干满足
   - 可以用更小的饼干替换，不影响其他孩子
   - 所以贪心策略是最优的
